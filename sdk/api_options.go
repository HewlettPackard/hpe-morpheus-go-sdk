/*
Morpheus API

Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.

API version: 8.0.6
Contact: dev@morpheusdata.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// OptionsAPIService OptionsAPI service
type OptionsAPIService service

type ApiGetOptionSourceDataRequest struct {
	ctx context.Context
	ApiService *OptionsAPIService
	optionSource string
}

func (r ApiGetOptionSourceDataRequest) Execute() (*GetOptionSourceData200Response, *http.Response, error) {
	return r.ApiService.GetOptionSourceDataExecute(r)
}

/*
GetOptionSourceData Get Option Source Data

Returns a list of name/value pairs for option-type models. Some option-types depend on input data for proper representation. This typically includes zoneId or siteId for the item being provisioned as request parameters or sometimes previous option type parameters. Each option returned has a `value`, which is often the `id`, but may be a `code` or other attribute.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param optionSource `optionSource` to be listed
 @return ApiGetOptionSourceDataRequest
*/
func (a *OptionsAPIService) GetOptionSourceData(ctx context.Context, optionSource string) ApiGetOptionSourceDataRequest {
	return ApiGetOptionSourceDataRequest{
		ApiService: a,
		ctx: ctx,
		optionSource: optionSource,
	}
}

// Execute executes the request
//  @return GetOptionSourceData200Response
func (a *OptionsAPIService) GetOptionSourceDataExecute(r ApiGetOptionSourceDataRequest) (*GetOptionSourceData200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetOptionSourceData200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OptionsAPIService.GetOptionSourceData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/options/{optionSource}"
	localVarPath = strings.Replace(localVarPath, "{"+"optionSource"+"}", url.PathEscape(parameterValueToString(r.optionSource, "optionSource")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCodeRepositoriesRequest struct {
	ctx context.Context
	ApiService *OptionsAPIService
	integrationId *int64
}

// Filter by an integration Id.
func (r ApiListCodeRepositoriesRequest) IntegrationId(integrationId int64) ApiListCodeRepositoriesRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListCodeRepositoriesRequest) Execute() (*ListCodeRepositories200Response, *http.Response, error) {
	return r.ApiService.ListCodeRepositoriesExecute(r)
}

/*
ListCodeRepositories Retrieves a list of Code/GIT Repositories

Retrieves a list of Code/GIT Repositories


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCodeRepositoriesRequest
*/
func (a *OptionsAPIService) ListCodeRepositories(ctx context.Context) ApiListCodeRepositoriesRequest {
	return ApiListCodeRepositoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListCodeRepositories200Response
func (a *OptionsAPIService) ListCodeRepositoriesExecute(r ApiListCodeRepositoriesRequest) (*ListCodeRepositories200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListCodeRepositories200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OptionsAPIService.ListCodeRepositories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/options/codeRepositories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOptionAnsibleTowerInventoryOptionsRequest struct {
	ctx context.Context
	ApiService *OptionsAPIService
	zoneId *int64
	siteId *int64
	taskId *int64
	accountId *int64
	ansibleTowerIntegrationId *int64
}

// The Zone ID for Filtering
func (r ApiListOptionAnsibleTowerInventoryOptionsRequest) ZoneId(zoneId int64) ApiListOptionAnsibleTowerInventoryOptionsRequest {
	r.zoneId = &zoneId
	return r
}

// The Site ID for Filtering
func (r ApiListOptionAnsibleTowerInventoryOptionsRequest) SiteId(siteId int64) ApiListOptionAnsibleTowerInventoryOptionsRequest {
	r.siteId = &siteId
	return r
}

// The Task ID for filtering
func (r ApiListOptionAnsibleTowerInventoryOptionsRequest) TaskId(taskId int64) ApiListOptionAnsibleTowerInventoryOptionsRequest {
	r.taskId = &taskId
	return r
}

// Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users.
func (r ApiListOptionAnsibleTowerInventoryOptionsRequest) AccountId(accountId int64) ApiListOptionAnsibleTowerInventoryOptionsRequest {
	r.accountId = &accountId
	return r
}

// Filter by an integration Id of an Ansible Tower Integration.
func (r ApiListOptionAnsibleTowerInventoryOptionsRequest) AnsibleTowerIntegrationId(ansibleTowerIntegrationId int64) ApiListOptionAnsibleTowerInventoryOptionsRequest {
	r.ansibleTowerIntegrationId = &ansibleTowerIntegrationId
	return r
}

func (r ApiListOptionAnsibleTowerInventoryOptionsRequest) Execute() (*ListOptionAnsibleTowerInventoryOptions200Response, *http.Response, error) {
	return r.ApiService.ListOptionAnsibleTowerInventoryOptionsExecute(r)
}

/*
ListOptionAnsibleTowerInventoryOptions Retrieves available Ansible Tower Inventories

This endpoint can be used to see which Ansible Tower Inventories are available for the current user/tenant


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOptionAnsibleTowerInventoryOptionsRequest
*/
func (a *OptionsAPIService) ListOptionAnsibleTowerInventoryOptions(ctx context.Context) ApiListOptionAnsibleTowerInventoryOptionsRequest {
	return ApiListOptionAnsibleTowerInventoryOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOptionAnsibleTowerInventoryOptions200Response
func (a *OptionsAPIService) ListOptionAnsibleTowerInventoryOptionsExecute(r ApiListOptionAnsibleTowerInventoryOptionsRequest) (*ListOptionAnsibleTowerInventoryOptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOptionAnsibleTowerInventoryOptions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OptionsAPIService.ListOptionAnsibleTowerInventoryOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/options/ansibleTowerInventory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.zoneId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zoneId", r.zoneId, "form", "")
	}
	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	}
	if r.taskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskId", r.taskId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.ansibleTowerIntegrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ansibleTowerIntegrationId", r.ansibleTowerIntegrationId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOptionAnsibleTowerJobTemplateOptionsRequest struct {
	ctx context.Context
	ApiService *OptionsAPIService
	zoneId *int64
	siteId *int64
	taskId *int64
	accountId *int64
	ansibleTowerIntegrationId *int64
}

// The Zone ID for Filtering
func (r ApiListOptionAnsibleTowerJobTemplateOptionsRequest) ZoneId(zoneId int64) ApiListOptionAnsibleTowerJobTemplateOptionsRequest {
	r.zoneId = &zoneId
	return r
}

// The Site ID for Filtering
func (r ApiListOptionAnsibleTowerJobTemplateOptionsRequest) SiteId(siteId int64) ApiListOptionAnsibleTowerJobTemplateOptionsRequest {
	r.siteId = &siteId
	return r
}

// The Task ID for filtering
func (r ApiListOptionAnsibleTowerJobTemplateOptionsRequest) TaskId(taskId int64) ApiListOptionAnsibleTowerJobTemplateOptionsRequest {
	r.taskId = &taskId
	return r
}

// Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users.
func (r ApiListOptionAnsibleTowerJobTemplateOptionsRequest) AccountId(accountId int64) ApiListOptionAnsibleTowerJobTemplateOptionsRequest {
	r.accountId = &accountId
	return r
}

// Filter by an integration Id of an Ansible Tower Integration.
func (r ApiListOptionAnsibleTowerJobTemplateOptionsRequest) AnsibleTowerIntegrationId(ansibleTowerIntegrationId int64) ApiListOptionAnsibleTowerJobTemplateOptionsRequest {
	r.ansibleTowerIntegrationId = &ansibleTowerIntegrationId
	return r
}

func (r ApiListOptionAnsibleTowerJobTemplateOptionsRequest) Execute() (*ListOptionAnsibleTowerInventoryOptions200Response, *http.Response, error) {
	return r.ApiService.ListOptionAnsibleTowerJobTemplateOptionsExecute(r)
}

/*
ListOptionAnsibleTowerJobTemplateOptions Retrieves available Ansible Tower Job Templates

This endpoint can be used to see which Ansible Tower Job Templates are available for the current user/tenant


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOptionAnsibleTowerJobTemplateOptionsRequest
*/
func (a *OptionsAPIService) ListOptionAnsibleTowerJobTemplateOptions(ctx context.Context) ApiListOptionAnsibleTowerJobTemplateOptionsRequest {
	return ApiListOptionAnsibleTowerJobTemplateOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOptionAnsibleTowerInventoryOptions200Response
func (a *OptionsAPIService) ListOptionAnsibleTowerJobTemplateOptionsExecute(r ApiListOptionAnsibleTowerJobTemplateOptionsRequest) (*ListOptionAnsibleTowerInventoryOptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOptionAnsibleTowerInventoryOptions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OptionsAPIService.ListOptionAnsibleTowerJobTemplateOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/options/ansibleTowerJobTemplate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.zoneId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zoneId", r.zoneId, "form", "")
	}
	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	}
	if r.taskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taskId", r.taskId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.ansibleTowerIntegrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ansibleTowerIntegrationId", r.ansibleTowerIntegrationId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOptionChefServerOptionsRequest struct {
	ctx context.Context
	ApiService *OptionsAPIService
	accountId *int64
}

// Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users.
func (r ApiListOptionChefServerOptionsRequest) AccountId(accountId int64) ApiListOptionChefServerOptionsRequest {
	r.accountId = &accountId
	return r
}

func (r ApiListOptionChefServerOptionsRequest) Execute() (*ListOptionAnsibleTowerInventoryOptions200Response, *http.Response, error) {
	return r.ApiService.ListOptionChefServerOptionsExecute(r)
}

/*
ListOptionChefServerOptions Retrieves available Chef Servers

This endpoint can be used to see which Chef Servers are available for the current user/tenant


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOptionChefServerOptionsRequest
*/
func (a *OptionsAPIService) ListOptionChefServerOptions(ctx context.Context) ApiListOptionChefServerOptionsRequest {
	return ApiListOptionChefServerOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOptionAnsibleTowerInventoryOptions200Response
func (a *OptionsAPIService) ListOptionChefServerOptionsExecute(r ApiListOptionChefServerOptionsRequest) (*ListOptionAnsibleTowerInventoryOptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOptionAnsibleTowerInventoryOptions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OptionsAPIService.ListOptionChefServerOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/options/chefServer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOptionNetworkOptionsRequest struct {
	ctx context.Context
	ApiService *OptionsAPIService
	zoneId *int64
	provisionTypeId *int64
}

// The Zone ID for Filtering
func (r ApiListOptionNetworkOptionsRequest) ZoneId(zoneId int64) ApiListOptionNetworkOptionsRequest {
	r.zoneId = &zoneId
	return r
}

// Provision type filter, restricts query to only load service plans of specified provision type
func (r ApiListOptionNetworkOptionsRequest) ProvisionTypeId(provisionTypeId int64) ApiListOptionNetworkOptionsRequest {
	r.provisionTypeId = &provisionTypeId
	return r
}

func (r ApiListOptionNetworkOptionsRequest) Execute() (*ListOptionNetworkOptions200Response, *http.Response, error) {
	return r.ApiService.ListOptionNetworkOptionsExecute(r)
}

/*
ListOptionNetworkOptions Retrieves network options by zone/cloud

This endpoint can be used to see which network options are available for a given cloud (zoneId) and provision type.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOptionNetworkOptionsRequest
*/
func (a *OptionsAPIService) ListOptionNetworkOptions(ctx context.Context) ApiListOptionNetworkOptionsRequest {
	return ApiListOptionNetworkOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOptionNetworkOptions200Response
func (a *OptionsAPIService) ListOptionNetworkOptionsExecute(r ApiListOptionNetworkOptionsRequest) (*ListOptionNetworkOptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOptionNetworkOptions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OptionsAPIService.ListOptionNetworkOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/options/zoneNetworkOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.zoneId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zoneId", r.zoneId, "form", "")
	}
	if r.provisionTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provisionTypeId", r.provisionTypeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOptionServiceNowWorkflowsOptionsRequest struct {
	ctx context.Context
	ApiService *OptionsAPIService
	accountId *int64
	config *map[string]interface{}
	accountIntegrationId *int64
}

// Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users.
func (r ApiListOptionServiceNowWorkflowsOptionsRequest) AccountId(accountId int64) ApiListOptionServiceNowWorkflowsOptionsRequest {
	r.accountId = &accountId
	return r
}

// Input parameters are required if the input is dependent on them.  Fields must be prefixed with &#x60;config.&#x60;
func (r ApiListOptionServiceNowWorkflowsOptionsRequest) Config(config map[string]interface{}) ApiListOptionServiceNowWorkflowsOptionsRequest {
	r.config = &config
	return r
}

// Filter by Account Integration ID.
func (r ApiListOptionServiceNowWorkflowsOptionsRequest) AccountIntegrationId(accountIntegrationId int64) ApiListOptionServiceNowWorkflowsOptionsRequest {
	r.accountIntegrationId = &accountIntegrationId
	return r
}

func (r ApiListOptionServiceNowWorkflowsOptionsRequest) Execute() (*ListOptionAnsibleTowerInventoryOptions200Response, *http.Response, error) {
	return r.ApiService.ListOptionServiceNowWorkflowsOptionsExecute(r)
}

/*
ListOptionServiceNowWorkflowsOptions Retrieves available ServiceNow workflows

This endpoint can be used to see which ServiceNow workflows are available for the current user/tenant


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOptionServiceNowWorkflowsOptionsRequest
*/
func (a *OptionsAPIService) ListOptionServiceNowWorkflowsOptions(ctx context.Context) ApiListOptionServiceNowWorkflowsOptionsRequest {
	return ApiListOptionServiceNowWorkflowsOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOptionAnsibleTowerInventoryOptions200Response
func (a *OptionsAPIService) ListOptionServiceNowWorkflowsOptionsExecute(r ApiListOptionServiceNowWorkflowsOptionsRequest) (*ListOptionAnsibleTowerInventoryOptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOptionAnsibleTowerInventoryOptions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OptionsAPIService.ListOptionServiceNowWorkflowsOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/options/serviceNowWorkflows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.config != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "config", r.config, "form", "")
	}
	if r.accountIntegrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountIntegrationId", r.accountIntegrationId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOptionValuesRequest struct {
	ctx context.Context
	ApiService *OptionsAPIService
	optionTypeId *int64
	config *map[string]interface{}
}

// Input or Option Type ID
func (r ApiListOptionValuesRequest) OptionTypeId(optionTypeId int64) ApiListOptionValuesRequest {
	r.optionTypeId = &optionTypeId
	return r
}

// Input parameters are required if the input is dependent on them.  Fields must be prefixed with &#x60;config.&#x60;
func (r ApiListOptionValuesRequest) Config(config map[string]interface{}) ApiListOptionValuesRequest {
	r.config = &config
	return r
}

func (r ApiListOptionValuesRequest) Execute() (*ListOptionValues200Response, *http.Response, error) {
	return r.ApiService.ListOptionValuesExecute(r)
}

/*
ListOptionValues Retrieves input option values

Retrieves all input option values.  Can be used with parameters to supply dependent input values.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOptionValuesRequest
*/
func (a *OptionsAPIService) ListOptionValues(ctx context.Context) ApiListOptionValuesRequest {
	return ApiListOptionValuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOptionValues200Response
func (a *OptionsAPIService) ListOptionValuesExecute(r ApiListOptionValuesRequest) (*ListOptionValues200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOptionValues200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OptionsAPIService.ListOptionValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/options/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.optionTypeId == nil {
		return localVarReturnValue, nil, reportError("optionTypeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "optionTypeId", r.optionTypeId, "form", "")
	if r.config != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "config", r.config, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOptionZoneTypesOptionsRequest struct {
	ctx context.Context
	ApiService *OptionsAPIService
}

func (r ApiListOptionZoneTypesOptionsRequest) Execute() (*ListOptionZoneTypesOptions200Response, *http.Response, error) {
	return r.ApiService.ListOptionZoneTypesOptionsExecute(r)
}

/*
ListOptionZoneTypesOptions Retrieves enabled zones/clouds

This endpoint can be used to see which zone/cloud types are enabled for the current tenant


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOptionZoneTypesOptionsRequest
*/
func (a *OptionsAPIService) ListOptionZoneTypesOptions(ctx context.Context) ApiListOptionZoneTypesOptionsRequest {
	return ApiListOptionZoneTypesOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOptionZoneTypesOptions200Response
func (a *OptionsAPIService) ListOptionZoneTypesOptionsExecute(r ApiListOptionZoneTypesOptionsRequest) (*ListOptionZoneTypesOptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOptionZoneTypesOptions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OptionsAPIService.ListOptionZoneTypesOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/options/zoneTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
