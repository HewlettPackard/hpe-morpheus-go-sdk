/*
Morpheus API

Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.

API version: 8.0.6
Contact: dev@morpheusdata.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ProvisioningLicensesAPIService ProvisioningLicensesAPI service
type ProvisioningLicensesAPIService service

type ApiAddProvisioningLicenseRequest struct {
	ctx context.Context
	ApiService *ProvisioningLicensesAPIService
	addProvisioningLicenseRequest *AddProvisioningLicenseRequest
}

func (r ApiAddProvisioningLicenseRequest) AddProvisioningLicenseRequest(addProvisioningLicenseRequest AddProvisioningLicenseRequest) ApiAddProvisioningLicenseRequest {
	r.addProvisioningLicenseRequest = &addProvisioningLicenseRequest
	return r
}

func (r ApiAddProvisioningLicenseRequest) Execute() (*AddProvisioningLicense200Response, *http.Response, error) {
	return r.ApiService.AddProvisioningLicenseExecute(r)
}

/*
AddProvisioningLicense Create a License

Use this command to create a new license.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddProvisioningLicenseRequest
*/
func (a *ProvisioningLicensesAPIService) AddProvisioningLicense(ctx context.Context) ApiAddProvisioningLicenseRequest {
	return ApiAddProvisioningLicenseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AddProvisioningLicense200Response
func (a *ProvisioningLicensesAPIService) AddProvisioningLicenseExecute(r ApiAddProvisioningLicenseRequest) (*AddProvisioningLicense200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddProvisioningLicense200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProvisioningLicensesAPIService.AddProvisioningLicense")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/provisioning-licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addProvisioningLicenseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProvisioningLicenseRequest struct {
	ctx context.Context
	ApiService *ProvisioningLicensesAPIService
	id int64
}

func (r ApiGetProvisioningLicenseRequest) Execute() (*GetProvisioningLicense200Response, *http.Response, error) {
	return r.ApiService.GetProvisioningLicenseExecute(r)
}

/*
GetProvisioningLicense Get a Specific License

This endpoint retrieves a specific license.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Morpheus ID of the Object being referenced
 @return ApiGetProvisioningLicenseRequest
*/
func (a *ProvisioningLicensesAPIService) GetProvisioningLicense(ctx context.Context, id int64) ApiGetProvisioningLicenseRequest {
	return ApiGetProvisioningLicenseRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetProvisioningLicense200Response
func (a *ProvisioningLicensesAPIService) GetProvisioningLicenseExecute(r ApiGetProvisioningLicenseRequest) (*GetProvisioningLicense200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProvisioningLicense200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProvisioningLicensesAPIService.GetProvisioningLicense")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/provisioning-licenses/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProvisioningLicenseReservationsRequest struct {
	ctx context.Context
	ApiService *ProvisioningLicensesAPIService
	id int64
}

func (r ApiGetProvisioningLicenseReservationsRequest) Execute() (*GetProvisioningLicenseReservations200Response, *http.Response, error) {
	return r.ApiService.GetProvisioningLicenseReservationsExecute(r)
}

/*
GetProvisioningLicenseReservations Get Reservations for Specific License

This endpoint retrieves all reservations for a specific license. Each time a license is applied to a new server, a reservation is created, reducing the available copies for the license.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Morpheus ID of the Object being referenced
 @return ApiGetProvisioningLicenseReservationsRequest
*/
func (a *ProvisioningLicensesAPIService) GetProvisioningLicenseReservations(ctx context.Context, id int64) ApiGetProvisioningLicenseReservationsRequest {
	return ApiGetProvisioningLicenseReservationsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetProvisioningLicenseReservations200Response
func (a *ProvisioningLicensesAPIService) GetProvisioningLicenseReservationsExecute(r ApiGetProvisioningLicenseReservationsRequest) (*GetProvisioningLicenseReservations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProvisioningLicenseReservations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProvisioningLicensesAPIService.GetProvisioningLicenseReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/provisioning-licenses/{id}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListProvisioningLicensesRequest struct {
	ctx context.Context
	ApiService *ProvisioningLicensesAPIService
	max *int64
	offset *int64
	sort *string
	direction *string
	phrase *string
	name *string
	licenseType *string
	licenseVersion *string
	orgName *string
	fullName *string
}

// Maximum number of records to return
func (r ApiListProvisioningLicensesRequest) Max(max int64) ApiListProvisioningLicensesRequest {
	r.max = &max
	return r
}

// Offset records, the number of records to skip, for paginating requests
func (r ApiListProvisioningLicensesRequest) Offset(offset int64) ApiListProvisioningLicensesRequest {
	r.offset = &offset
	return r
}

// Sort order, the name of the property to sort by
func (r ApiListProvisioningLicensesRequest) Sort(sort string) ApiListProvisioningLicensesRequest {
	r.sort = &sort
	return r
}

// Sort direction, use &#39;desc&#39; to reverse sort
func (r ApiListProvisioningLicensesRequest) Direction(direction string) ApiListProvisioningLicensesRequest {
	r.direction = &direction
	return r
}

// Search phrase for partial matches on name or description
func (r ApiListProvisioningLicensesRequest) Phrase(phrase string) ApiListProvisioningLicensesRequest {
	r.phrase = &phrase
	return r
}

// Filter by name
func (r ApiListProvisioningLicensesRequest) Name(name string) ApiListProvisioningLicensesRequest {
	r.name = &name
	return r
}

// If specified will return an exact match on licenseType code
func (r ApiListProvisioningLicensesRequest) LicenseType(licenseType string) ApiListProvisioningLicensesRequest {
	r.licenseType = &licenseType
	return r
}

// If specified will return an exact match on licenseVersion
func (r ApiListProvisioningLicensesRequest) LicenseVersion(licenseVersion string) ApiListProvisioningLicensesRequest {
	r.licenseVersion = &licenseVersion
	return r
}

// If specified will return an exact match on orgName
func (r ApiListProvisioningLicensesRequest) OrgName(orgName string) ApiListProvisioningLicensesRequest {
	r.orgName = &orgName
	return r
}

// If specified will return an exact match on fullName
func (r ApiListProvisioningLicensesRequest) FullName(fullName string) ApiListProvisioningLicensesRequest {
	r.fullName = &fullName
	return r
}

func (r ApiListProvisioningLicensesRequest) Execute() (*ListProvisioningLicenses200Response, *http.Response, error) {
	return r.ApiService.ListProvisioningLicensesExecute(r)
}

/*
ListProvisioningLicenses Get All Licenses

This endpoint retrieves all licenses.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListProvisioningLicensesRequest
*/
func (a *ProvisioningLicensesAPIService) ListProvisioningLicenses(ctx context.Context) ApiListProvisioningLicensesRequest {
	return ApiListProvisioningLicensesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListProvisioningLicenses200Response
func (a *ProvisioningLicensesAPIService) ListProvisioningLicensesExecute(r ApiListProvisioningLicensesRequest) (*ListProvisioningLicenses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListProvisioningLicenses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProvisioningLicensesAPIService.ListProvisioningLicenses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/provisioning-licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	} else {
		var defaultValue int64 = 25
		r.max = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "name"
		r.sort = &defaultValue
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "form", "")
	} else {
		var defaultValue string = "asc"
		r.direction = &defaultValue
	}
	if r.phrase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phrase", r.phrase, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.licenseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "licenseType", r.licenseType, "form", "")
	}
	if r.licenseVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "licenseVersion", r.licenseVersion, "form", "")
	}
	if r.orgName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orgName", r.orgName, "form", "")
	}
	if r.fullName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fullName", r.fullName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveProvisioningLicenseRequest struct {
	ctx context.Context
	ApiService *ProvisioningLicensesAPIService
	id int64
}

func (r ApiRemoveProvisioningLicenseRequest) Execute() (*DeleteAlerts200Response, *http.Response, error) {
	return r.ApiService.RemoveProvisioningLicenseExecute(r)
}

/*
RemoveProvisioningLicense Delete a License

Will delete a license.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Morpheus ID of the Object being referenced
 @return ApiRemoveProvisioningLicenseRequest
*/
func (a *ProvisioningLicensesAPIService) RemoveProvisioningLicense(ctx context.Context, id int64) ApiRemoveProvisioningLicenseRequest {
	return ApiRemoveProvisioningLicenseRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeleteAlerts200Response
func (a *ProvisioningLicensesAPIService) RemoveProvisioningLicenseExecute(r ApiRemoveProvisioningLicenseRequest) (*DeleteAlerts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteAlerts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProvisioningLicensesAPIService.RemoveProvisioningLicense")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/provisioning-licenses/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProvisioningLicenseRequest struct {
	ctx context.Context
	ApiService *ProvisioningLicensesAPIService
	id int64
	updateProvisioningLicenseRequest *UpdateProvisioningLicenseRequest
}

func (r ApiUpdateProvisioningLicenseRequest) UpdateProvisioningLicenseRequest(updateProvisioningLicenseRequest UpdateProvisioningLicenseRequest) ApiUpdateProvisioningLicenseRequest {
	r.updateProvisioningLicenseRequest = &updateProvisioningLicenseRequest
	return r
}

func (r ApiUpdateProvisioningLicenseRequest) Execute() (*AddProvisioningLicense200Response, *http.Response, error) {
	return r.ApiService.UpdateProvisioningLicenseExecute(r)
}

/*
UpdateProvisioningLicense Update a License

Use this command to update an existing license.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Morpheus ID of the Object being referenced
 @return ApiUpdateProvisioningLicenseRequest
*/
func (a *ProvisioningLicensesAPIService) UpdateProvisioningLicense(ctx context.Context, id int64) ApiUpdateProvisioningLicenseRequest {
	return ApiUpdateProvisioningLicenseRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AddProvisioningLicense200Response
func (a *ProvisioningLicensesAPIService) UpdateProvisioningLicenseExecute(r ApiUpdateProvisioningLicenseRequest) (*AddProvisioningLicense200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddProvisioningLicense200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProvisioningLicensesAPIService.UpdateProvisioningLicense")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/provisioning-licenses/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateProvisioningLicenseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
