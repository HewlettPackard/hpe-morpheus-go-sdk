/*
Morpheus API

Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.

API version: 8.0.7
Contact: dev@morpheusdata.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"errors"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// ChecksAPIService ChecksAPI service
type ChecksAPIService service

type ApiAddCheckAppsRequest struct {
	ctx                 context.Context
	ApiService          *ChecksAPIService
	addCheckAppsRequest *AddCheckAppsRequest
}

func (r ApiAddCheckAppsRequest) AddCheckAppsRequest(addCheckAppsRequest AddCheckAppsRequest) ApiAddCheckAppsRequest {
	r.addCheckAppsRequest = &addCheckAppsRequest
	return r
}

func (r ApiAddCheckAppsRequest) Execute() (*AddCheckApps200Response, *http.Response, error) {
	return r.ApiService.AddCheckAppsExecute(r)
}

/*
AddCheckApps Create a New Check App

Create a new check app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddCheckAppsRequest
*/
func (a *ChecksAPIService) AddCheckApps(ctx context.Context) ApiAddCheckAppsRequest {
	return ApiAddCheckAppsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AddCheckApps200Response
func (a *ChecksAPIService) AddCheckAppsExecute(r ApiAddCheckAppsRequest) (*AddCheckApps200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddCheckApps200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.AddCheckApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addCheckAppsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddCheckGroupsRequest struct {
	ctx                   context.Context
	ApiService            *ChecksAPIService
	addCheckGroupsRequest *AddCheckGroupsRequest
}

func (r ApiAddCheckGroupsRequest) AddCheckGroupsRequest(addCheckGroupsRequest AddCheckGroupsRequest) ApiAddCheckGroupsRequest {
	r.addCheckGroupsRequest = &addCheckGroupsRequest
	return r
}

func (r ApiAddCheckGroupsRequest) Execute() (*AddCheckGroups200Response, *http.Response, error) {
	return r.ApiService.AddCheckGroupsExecute(r)
}

/*
AddCheckGroups Create a New Check Group

Create a new check group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddCheckGroupsRequest
*/
func (a *ChecksAPIService) AddCheckGroups(ctx context.Context) ApiAddCheckGroupsRequest {
	return ApiAddCheckGroupsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AddCheckGroups200Response
func (a *ChecksAPIService) AddCheckGroupsExecute(r ApiAddCheckGroupsRequest) (*AddCheckGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddCheckGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.AddCheckGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addCheckGroupsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddChecksRequest struct {
	ctx              context.Context
	ApiService       *ChecksAPIService
	addChecksRequest *AddChecksRequest
}

func (r ApiAddChecksRequest) AddChecksRequest(addChecksRequest AddChecksRequest) ApiAddChecksRequest {
	r.addChecksRequest = &addChecksRequest
	return r
}

func (r ApiAddChecksRequest) Execute() (*AddChecks200Response, *http.Response, error) {
	return r.ApiService.AddChecksExecute(r)
}

/*
AddChecks Create a New Check

Create a new monitoring check.

SSH tunneling options allow the different check types to tunnel to a host via a proxy, and execute checks relative to the proxy. A SSH tunnel can use your account generated public and private key-pairs or SSH password. It is strongly recommended to use a key-pair.

To enable SSH tunneling for a check, add `tunnelOn`, `sshHost`, `sshUser`, and optionally, `sshPort` and `sshPassword` parameters to any check type config as seen earlier in the Check Types section.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddChecksRequest
*/
func (a *ChecksAPIService) AddChecks(ctx context.Context) ApiAddChecksRequest {
	return ApiAddChecksRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AddChecks200Response
func (a *ChecksAPIService) AddChecksExecute(r ApiAddChecksRequest) (*AddChecks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddChecks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.AddChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/checks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addChecksRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCheckAppsRequest struct {
	ctx        context.Context
	ApiService *ChecksAPIService
	id         int64
}

func (r ApiDeleteCheckAppsRequest) Execute() (*DeleteAlerts200Response, *http.Response, error) {
	return r.ApiService.DeleteCheckAppsExecute(r)
}

/*
DeleteCheckApps Delete a Specific Check App

Delete an existing monitoring check app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiDeleteCheckAppsRequest
*/
func (a *ChecksAPIService) DeleteCheckApps(ctx context.Context, id int64) ApiDeleteCheckAppsRequest {
	return ApiDeleteCheckAppsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DeleteAlerts200Response
func (a *ChecksAPIService) DeleteCheckAppsExecute(r ApiDeleteCheckAppsRequest) (*DeleteAlerts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteAlerts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.DeleteCheckApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCheckGroupsRequest struct {
	ctx        context.Context
	ApiService *ChecksAPIService
	id         int64
}

func (r ApiDeleteCheckGroupsRequest) Execute() (*DeleteAlerts200Response, *http.Response, error) {
	return r.ApiService.DeleteCheckGroupsExecute(r)
}

/*
DeleteCheckGroups Delete a Specific Check Group

Delete an existing monitoring check group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiDeleteCheckGroupsRequest
*/
func (a *ChecksAPIService) DeleteCheckGroups(ctx context.Context, id int64) ApiDeleteCheckGroupsRequest {
	return ApiDeleteCheckGroupsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DeleteAlerts200Response
func (a *ChecksAPIService) DeleteCheckGroupsExecute(r ApiDeleteCheckGroupsRequest) (*DeleteAlerts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteAlerts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.DeleteCheckGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChecksRequest struct {
	ctx        context.Context
	ApiService *ChecksAPIService
	id         int64
}

func (r ApiDeleteChecksRequest) Execute() (*DeleteAlerts200Response, *http.Response, error) {
	return r.ApiService.DeleteChecksExecute(r)
}

/*
DeleteChecks Delete a Specific Check

Delete an existing monitoring check.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiDeleteChecksRequest
*/
func (a *ChecksAPIService) DeleteChecks(ctx context.Context, id int64) ApiDeleteChecksRequest {
	return ApiDeleteChecksRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DeleteAlerts200Response
func (a *ChecksAPIService) DeleteChecksExecute(r ApiDeleteChecksRequest) (*DeleteAlerts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteAlerts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.DeleteChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/checks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCheckAppsRequest struct {
	ctx        context.Context
	ApiService *ChecksAPIService
	id         int64
}

func (r ApiGetCheckAppsRequest) Execute() (*GetCheckApps200Response, *http.Response, error) {
	return r.ApiService.GetCheckAppsExecute(r)
}

/*
GetCheckApps Get a Specific Check App

Get details about a specific monitoring check app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiGetCheckAppsRequest
*/
func (a *ChecksAPIService) GetCheckApps(ctx context.Context, id int64) ApiGetCheckAppsRequest {
	return ApiGetCheckAppsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return GetCheckApps200Response
func (a *ChecksAPIService) GetCheckAppsExecute(r ApiGetCheckAppsRequest) (*GetCheckApps200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCheckApps200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.GetCheckApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCheckGroupsRequest struct {
	ctx        context.Context
	ApiService *ChecksAPIService
	id         int64
}

func (r ApiGetCheckGroupsRequest) Execute() (*GetCheckGroups200Response, *http.Response, error) {
	return r.ApiService.GetCheckGroupsExecute(r)
}

/*
GetCheckGroups Get a Specific Check Group

Get details about a specific monitoring check group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiGetCheckGroupsRequest
*/
func (a *ChecksAPIService) GetCheckGroups(ctx context.Context, id int64) ApiGetCheckGroupsRequest {
	return ApiGetCheckGroupsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return GetCheckGroups200Response
func (a *ChecksAPIService) GetCheckGroupsExecute(r ApiGetCheckGroupsRequest) (*GetCheckGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCheckGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.GetCheckGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCheckTypesRequest struct {
	ctx        context.Context
	ApiService *ChecksAPIService
	id         int64
}

func (r ApiGetCheckTypesRequest) Execute() (*GetCheckTypes200Response, *http.Response, error) {
	return r.ApiService.GetCheckTypesExecute(r)
}

/*
GetCheckTypes Get a Specific Check Type

Get details about a specific monitoring check type.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiGetCheckTypesRequest
*/
func (a *ChecksAPIService) GetCheckTypes(ctx context.Context, id int64) ApiGetCheckTypesRequest {
	return ApiGetCheckTypesRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return GetCheckTypes200Response
func (a *ChecksAPIService) GetCheckTypesExecute(r ApiGetCheckTypesRequest) (*GetCheckTypes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetCheckTypes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.GetCheckTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/check-types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChecksRequest struct {
	ctx        context.Context
	ApiService *ChecksAPIService
	id         int64
}

func (r ApiGetChecksRequest) Execute() (*GetChecks200Response, *http.Response, error) {
	return r.ApiService.GetChecksExecute(r)
}

/*
GetChecks Get a Specific Check

Get details about a specific monitoring check.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiGetChecksRequest
*/
func (a *ChecksAPIService) GetChecks(ctx context.Context, id int64) ApiGetChecksRequest {
	return ApiGetChecksRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return GetChecks200Response
func (a *ChecksAPIService) GetChecksExecute(r ApiGetChecksRequest) (*GetChecks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetChecks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.GetChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/checks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCheckAppsRequest struct {
	ctx         context.Context
	ApiService  *ChecksAPIService
	max         *int64
	offset      *int64
	sort        *string
	name        *string
	phrase      *string
	status      *string
	lastUpdated *time.Time
	deleted     *bool
}

// Maximum number of records to return
func (r ApiListCheckAppsRequest) Max(max int64) ApiListCheckAppsRequest {
	r.max = &max
	return r
}

// Offset records, the number of records to skip, for paginating requests
func (r ApiListCheckAppsRequest) Offset(offset int64) ApiListCheckAppsRequest {
	r.offset = &offset
	return r
}

// Sort order, the name of the property to sort by
func (r ApiListCheckAppsRequest) Sort(sort string) ApiListCheckAppsRequest {
	r.sort = &sort
	return r
}

// Filter by name
func (r ApiListCheckAppsRequest) Name(name string) ApiListCheckAppsRequest {
	r.name = &name
	return r
}

// Search phrase for partial matches on name or description
func (r ApiListCheckAppsRequest) Phrase(phrase string) ApiListCheckAppsRequest {
	r.phrase = &phrase
	return r
}

// The instance status for filtering.
func (r ApiListCheckAppsRequest) Status(status string) ApiListCheckAppsRequest {
	r.status = &status
	return r
}

// Date filter, restricts query to only load resources updated more recently than the date specified (ISO 8601)
func (r ApiListCheckAppsRequest) LastUpdated(lastUpdated time.Time) ApiListCheckAppsRequest {
	r.lastUpdated = &lastUpdated
	return r
}

// If true, only deleted resources or instances in pending removal status are returned.
func (r ApiListCheckAppsRequest) Deleted(deleted bool) ApiListCheckAppsRequest {
	r.deleted = &deleted
	return r
}

func (r ApiListCheckAppsRequest) Execute() (*ListCheckApps200Response, *http.Response, error) {
	return r.ApiService.ListCheckAppsExecute(r)
}

/*
ListCheckApps List All Check Apps

Get a list of check apps.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListCheckAppsRequest
*/
func (a *ChecksAPIService) ListCheckApps(ctx context.Context) ApiListCheckAppsRequest {
	return ApiListCheckAppsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListCheckApps200Response
func (a *ChecksAPIService) ListCheckAppsExecute(r ApiListCheckAppsRequest) (*ListCheckApps200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListCheckApps200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.ListCheckApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	} else {
		var defaultValue int64 = 25
		r.max = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "name"
		r.sort = &defaultValue
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.phrase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phrase", r.phrase, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.lastUpdated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastUpdated", r.lastUpdated, "form", "")
	}
	if r.deleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted", r.deleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCheckGroupsRequest struct {
	ctx         context.Context
	ApiService  *ChecksAPIService
	max         *int64
	offset      *int64
	sort        *string
	name        *string
	phrase      *string
	status      *string
	lastUpdated *time.Time
	deleted     *bool
}

// Maximum number of records to return
func (r ApiListCheckGroupsRequest) Max(max int64) ApiListCheckGroupsRequest {
	r.max = &max
	return r
}

// Offset records, the number of records to skip, for paginating requests
func (r ApiListCheckGroupsRequest) Offset(offset int64) ApiListCheckGroupsRequest {
	r.offset = &offset
	return r
}

// Sort order, the name of the property to sort by
func (r ApiListCheckGroupsRequest) Sort(sort string) ApiListCheckGroupsRequest {
	r.sort = &sort
	return r
}

// Filter by name
func (r ApiListCheckGroupsRequest) Name(name string) ApiListCheckGroupsRequest {
	r.name = &name
	return r
}

// Search phrase for partial matches on name or description
func (r ApiListCheckGroupsRequest) Phrase(phrase string) ApiListCheckGroupsRequest {
	r.phrase = &phrase
	return r
}

// The instance status for filtering.
func (r ApiListCheckGroupsRequest) Status(status string) ApiListCheckGroupsRequest {
	r.status = &status
	return r
}

// Date filter, restricts query to only load resources updated more recently than the date specified (ISO 8601)
func (r ApiListCheckGroupsRequest) LastUpdated(lastUpdated time.Time) ApiListCheckGroupsRequest {
	r.lastUpdated = &lastUpdated
	return r
}

// If true, only deleted resources or instances in pending removal status are returned.
func (r ApiListCheckGroupsRequest) Deleted(deleted bool) ApiListCheckGroupsRequest {
	r.deleted = &deleted
	return r
}

func (r ApiListCheckGroupsRequest) Execute() (*ListCheckGroups200Response, *http.Response, error) {
	return r.ApiService.ListCheckGroupsExecute(r)
}

/*
ListCheckGroups List All Check Groups

Get a list of check groups.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListCheckGroupsRequest
*/
func (a *ChecksAPIService) ListCheckGroups(ctx context.Context) ApiListCheckGroupsRequest {
	return ApiListCheckGroupsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListCheckGroups200Response
func (a *ChecksAPIService) ListCheckGroupsExecute(r ApiListCheckGroupsRequest) (*ListCheckGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListCheckGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.ListCheckGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	} else {
		var defaultValue int64 = 25
		r.max = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "name"
		r.sort = &defaultValue
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.phrase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phrase", r.phrase, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.lastUpdated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastUpdated", r.lastUpdated, "form", "")
	}
	if r.deleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted", r.deleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCheckTypesRequest struct {
	ctx        context.Context
	ApiService *ChecksAPIService
	max        *int64
	offset     *int64
	sort       *string
	name       *string
	phrase     *string
}

// Maximum number of records to return
func (r ApiListCheckTypesRequest) Max(max int64) ApiListCheckTypesRequest {
	r.max = &max
	return r
}

// Offset records, the number of records to skip, for paginating requests
func (r ApiListCheckTypesRequest) Offset(offset int64) ApiListCheckTypesRequest {
	r.offset = &offset
	return r
}

// Sort order, the name of the property to sort by
func (r ApiListCheckTypesRequest) Sort(sort string) ApiListCheckTypesRequest {
	r.sort = &sort
	return r
}

// Filter by name
func (r ApiListCheckTypesRequest) Name(name string) ApiListCheckTypesRequest {
	r.name = &name
	return r
}

// Search phrase for partial matches on name or description
func (r ApiListCheckTypesRequest) Phrase(phrase string) ApiListCheckTypesRequest {
	r.phrase = &phrase
	return r
}

func (r ApiListCheckTypesRequest) Execute() (*ListCheckTypes200Response, *http.Response, error) {
	return r.ApiService.ListCheckTypesExecute(r)
}

/*
ListCheckTypes List All Check Types

Get a list of monitoring check types.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListCheckTypesRequest
*/
func (a *ChecksAPIService) ListCheckTypes(ctx context.Context) ApiListCheckTypesRequest {
	return ApiListCheckTypesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListCheckTypes200Response
func (a *ChecksAPIService) ListCheckTypesExecute(r ApiListCheckTypesRequest) (*ListCheckTypes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListCheckTypes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.ListCheckTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/check-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	} else {
		var defaultValue int64 = 25
		r.max = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "name"
		r.sort = &defaultValue
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.phrase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phrase", r.phrase, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListChecksRequest struct {
	ctx         context.Context
	ApiService  *ChecksAPIService
	max         *int64
	offset      *int64
	sort        *string
	name        *string
	phrase      *string
	status      *string
	lastUpdated *time.Time
	deleted     *bool
}

// Maximum number of records to return
func (r ApiListChecksRequest) Max(max int64) ApiListChecksRequest {
	r.max = &max
	return r
}

// Offset records, the number of records to skip, for paginating requests
func (r ApiListChecksRequest) Offset(offset int64) ApiListChecksRequest {
	r.offset = &offset
	return r
}

// Sort order, the name of the property to sort by
func (r ApiListChecksRequest) Sort(sort string) ApiListChecksRequest {
	r.sort = &sort
	return r
}

// Filter by name
func (r ApiListChecksRequest) Name(name string) ApiListChecksRequest {
	r.name = &name
	return r
}

// Search phrase for partial matches on name or description
func (r ApiListChecksRequest) Phrase(phrase string) ApiListChecksRequest {
	r.phrase = &phrase
	return r
}

// Filter by health status.
func (r ApiListChecksRequest) Status(status string) ApiListChecksRequest {
	r.status = &status
	return r
}

// Date filter, restricts query to only load resources updated more recently than the date specified (ISO 8601)
func (r ApiListChecksRequest) LastUpdated(lastUpdated time.Time) ApiListChecksRequest {
	r.lastUpdated = &lastUpdated
	return r
}

// If true, only deleted resources or instances in pending removal status are returned.
func (r ApiListChecksRequest) Deleted(deleted bool) ApiListChecksRequest {
	r.deleted = &deleted
	return r
}

func (r ApiListChecksRequest) Execute() (*ListChecks200Response, *http.Response, error) {
	return r.ApiService.ListChecksExecute(r)
}

/*
ListChecks List All Checks

Get a list of monitoring checks.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListChecksRequest
*/
func (a *ChecksAPIService) ListChecks(ctx context.Context) ApiListChecksRequest {
	return ApiListChecksRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListChecks200Response
func (a *ChecksAPIService) ListChecksExecute(r ApiListChecksRequest) (*ListChecks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListChecks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.ListChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/checks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	} else {
		var defaultValue int64 = 25
		r.max = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "name"
		r.sort = &defaultValue
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.phrase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phrase", r.phrase, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.lastUpdated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastUpdated", r.lastUpdated, "form", "")
	}
	if r.deleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted", r.deleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCheckAppsRequest struct {
	ctx                    context.Context
	ApiService             *ChecksAPIService
	id                     int64
	updateCheckAppsRequest *UpdateCheckAppsRequest
}

func (r ApiUpdateCheckAppsRequest) UpdateCheckAppsRequest(updateCheckAppsRequest UpdateCheckAppsRequest) ApiUpdateCheckAppsRequest {
	r.updateCheckAppsRequest = &updateCheckAppsRequest
	return r
}

func (r ApiUpdateCheckAppsRequest) Execute() (*UpdateCheckApps200Response, *http.Response, error) {
	return r.ApiService.UpdateCheckAppsExecute(r)
}

/*
UpdateCheckApps Update Check App

Update an existing monitoring check app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiUpdateCheckAppsRequest
*/
func (a *ChecksAPIService) UpdateCheckApps(ctx context.Context, id int64) ApiUpdateCheckAppsRequest {
	return ApiUpdateCheckAppsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return UpdateCheckApps200Response
func (a *ChecksAPIService) UpdateCheckAppsExecute(r ApiUpdateCheckAppsRequest) (*UpdateCheckApps200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateCheckApps200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.UpdateCheckApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCheckAppsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCheckGroupsRequest struct {
	ctx                      context.Context
	ApiService               *ChecksAPIService
	id                       int64
	updateCheckGroupsRequest *UpdateCheckGroupsRequest
}

func (r ApiUpdateCheckGroupsRequest) UpdateCheckGroupsRequest(updateCheckGroupsRequest UpdateCheckGroupsRequest) ApiUpdateCheckGroupsRequest {
	r.updateCheckGroupsRequest = &updateCheckGroupsRequest
	return r
}

func (r ApiUpdateCheckGroupsRequest) Execute() (*AddCheckGroups200Response, *http.Response, error) {
	return r.ApiService.UpdateCheckGroupsExecute(r)
}

/*
UpdateCheckGroups Update Check Group

Update an existing monitoring check group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiUpdateCheckGroupsRequest
*/
func (a *ChecksAPIService) UpdateCheckGroups(ctx context.Context, id int64) ApiUpdateCheckGroupsRequest {
	return ApiUpdateCheckGroupsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AddCheckGroups200Response
func (a *ChecksAPIService) UpdateCheckGroupsExecute(r ApiUpdateCheckGroupsRequest) (*AddCheckGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddCheckGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.UpdateCheckGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCheckGroupsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateChecksRequest struct {
	ctx                 context.Context
	ApiService          *ChecksAPIService
	id                  int64
	updateChecksRequest *UpdateChecksRequest
}

func (r ApiUpdateChecksRequest) UpdateChecksRequest(updateChecksRequest UpdateChecksRequest) ApiUpdateChecksRequest {
	r.updateChecksRequest = &updateChecksRequest
	return r
}

func (r ApiUpdateChecksRequest) Execute() (*AddChecks200Response, *http.Response, error) {
	return r.ApiService.UpdateChecksExecute(r)
}

/*
UpdateChecks Updates a Check

Updates a monitoring check.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiUpdateChecksRequest
*/
func (a *ChecksAPIService) UpdateChecks(ctx context.Context, id int64) ApiUpdateChecksRequest {
	return ApiUpdateChecksRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AddChecks200Response
func (a *ChecksAPIService) UpdateChecksExecute(r ApiUpdateChecksRequest) (*AddChecks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddChecks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.UpdateChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/checks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateChecksRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMuteAllCheckAppsRequest struct {
	ctx                           context.Context
	ApiService                    *ChecksAPIService
	updateMuteAllCheckAppsRequest *UpdateMuteAllCheckAppsRequest
}

func (r ApiUpdateMuteAllCheckAppsRequest) UpdateMuteAllCheckAppsRequest(updateMuteAllCheckAppsRequest UpdateMuteAllCheckAppsRequest) ApiUpdateMuteAllCheckAppsRequest {
	r.updateMuteAllCheckAppsRequest = &updateMuteAllCheckAppsRequest
	return r
}

func (r ApiUpdateMuteAllCheckAppsRequest) Execute() (*UpdateMuteAllCheckApps200Response, *http.Response, error) {
	return r.ApiService.UpdateMuteAllCheckAppsExecute(r)
}

/*
UpdateMuteAllCheckApps Mute All Check Apps

Mute all existing check apps.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateMuteAllCheckAppsRequest
*/
func (a *ChecksAPIService) UpdateMuteAllCheckApps(ctx context.Context) ApiUpdateMuteAllCheckAppsRequest {
	return ApiUpdateMuteAllCheckAppsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UpdateMuteAllCheckApps200Response
func (a *ChecksAPIService) UpdateMuteAllCheckAppsExecute(r ApiUpdateMuteAllCheckAppsRequest) (*UpdateMuteAllCheckApps200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateMuteAllCheckApps200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.UpdateMuteAllCheckApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/apps/mute-all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateMuteAllCheckAppsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMuteAllCheckGroupsRequest struct {
	ctx                           context.Context
	ApiService                    *ChecksAPIService
	updateMuteAllCheckAppsRequest *UpdateMuteAllCheckAppsRequest
}

func (r ApiUpdateMuteAllCheckGroupsRequest) UpdateMuteAllCheckAppsRequest(updateMuteAllCheckAppsRequest UpdateMuteAllCheckAppsRequest) ApiUpdateMuteAllCheckGroupsRequest {
	r.updateMuteAllCheckAppsRequest = &updateMuteAllCheckAppsRequest
	return r
}

func (r ApiUpdateMuteAllCheckGroupsRequest) Execute() (*UpdateMuteAllCheckApps200Response, *http.Response, error) {
	return r.ApiService.UpdateMuteAllCheckGroupsExecute(r)
}

/*
UpdateMuteAllCheckGroups Mute All Check Groups

Mute all existing check groups.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateMuteAllCheckGroupsRequest
*/
func (a *ChecksAPIService) UpdateMuteAllCheckGroups(ctx context.Context) ApiUpdateMuteAllCheckGroupsRequest {
	return ApiUpdateMuteAllCheckGroupsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UpdateMuteAllCheckApps200Response
func (a *ChecksAPIService) UpdateMuteAllCheckGroupsExecute(r ApiUpdateMuteAllCheckGroupsRequest) (*UpdateMuteAllCheckApps200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateMuteAllCheckApps200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.UpdateMuteAllCheckGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/groups/mute-all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateMuteAllCheckAppsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMuteAllChecksRequest struct {
	ctx                           context.Context
	ApiService                    *ChecksAPIService
	updateMuteAllCheckAppsRequest *UpdateMuteAllCheckAppsRequest
}

func (r ApiUpdateMuteAllChecksRequest) UpdateMuteAllCheckAppsRequest(updateMuteAllCheckAppsRequest UpdateMuteAllCheckAppsRequest) ApiUpdateMuteAllChecksRequest {
	r.updateMuteAllCheckAppsRequest = &updateMuteAllCheckAppsRequest
	return r
}

func (r ApiUpdateMuteAllChecksRequest) Execute() (*UpdateMuteAllCheckApps200Response, *http.Response, error) {
	return r.ApiService.UpdateMuteAllChecksExecute(r)
}

/*
UpdateMuteAllChecks Mute All Checks

Mute all existing checks.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateMuteAllChecksRequest
*/
func (a *ChecksAPIService) UpdateMuteAllChecks(ctx context.Context) ApiUpdateMuteAllChecksRequest {
	return ApiUpdateMuteAllChecksRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UpdateMuteAllCheckApps200Response
func (a *ChecksAPIService) UpdateMuteAllChecksExecute(r ApiUpdateMuteAllChecksRequest) (*UpdateMuteAllCheckApps200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateMuteAllCheckApps200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.UpdateMuteAllChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/checks/mute-all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateMuteAllCheckAppsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMuteCheckAppsRequest struct {
	ctx                           context.Context
	ApiService                    *ChecksAPIService
	id                            int64
	updateMuteAllCheckAppsRequest *UpdateMuteAllCheckAppsRequest
}

func (r ApiUpdateMuteCheckAppsRequest) UpdateMuteAllCheckAppsRequest(updateMuteAllCheckAppsRequest UpdateMuteAllCheckAppsRequest) ApiUpdateMuteCheckAppsRequest {
	r.updateMuteAllCheckAppsRequest = &updateMuteAllCheckAppsRequest
	return r
}

func (r ApiUpdateMuteCheckAppsRequest) Execute() (*UpdateMuteCheckApps200Response, *http.Response, error) {
	return r.ApiService.UpdateMuteCheckAppsExecute(r)
}

/*
UpdateMuteCheckApps Mute Check App

Mute an existing check app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiUpdateMuteCheckAppsRequest
*/
func (a *ChecksAPIService) UpdateMuteCheckApps(ctx context.Context, id int64) ApiUpdateMuteCheckAppsRequest {
	return ApiUpdateMuteCheckAppsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return UpdateMuteCheckApps200Response
func (a *ChecksAPIService) UpdateMuteCheckAppsExecute(r ApiUpdateMuteCheckAppsRequest) (*UpdateMuteCheckApps200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateMuteCheckApps200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.UpdateMuteCheckApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/apps/{id}/mute"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateMuteAllCheckAppsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMuteCheckGroupsRequest struct {
	ctx                           context.Context
	ApiService                    *ChecksAPIService
	id                            int64
	updateMuteAllCheckAppsRequest *UpdateMuteAllCheckAppsRequest
}

func (r ApiUpdateMuteCheckGroupsRequest) UpdateMuteAllCheckAppsRequest(updateMuteAllCheckAppsRequest UpdateMuteAllCheckAppsRequest) ApiUpdateMuteCheckGroupsRequest {
	r.updateMuteAllCheckAppsRequest = &updateMuteAllCheckAppsRequest
	return r
}

func (r ApiUpdateMuteCheckGroupsRequest) Execute() (*UpdateMuteCheckApps200Response, *http.Response, error) {
	return r.ApiService.UpdateMuteCheckGroupsExecute(r)
}

/*
UpdateMuteCheckGroups Mute Check Group

Mute an existing check group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiUpdateMuteCheckGroupsRequest
*/
func (a *ChecksAPIService) UpdateMuteCheckGroups(ctx context.Context, id int64) ApiUpdateMuteCheckGroupsRequest {
	return ApiUpdateMuteCheckGroupsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return UpdateMuteCheckApps200Response
func (a *ChecksAPIService) UpdateMuteCheckGroupsExecute(r ApiUpdateMuteCheckGroupsRequest) (*UpdateMuteCheckApps200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateMuteCheckApps200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.UpdateMuteCheckGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/groups/{id}/mute"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateMuteAllCheckAppsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMuteChecksRequest struct {
	ctx                           context.Context
	ApiService                    *ChecksAPIService
	id                            int64
	updateMuteAllCheckAppsRequest *UpdateMuteAllCheckAppsRequest
}

func (r ApiUpdateMuteChecksRequest) UpdateMuteAllCheckAppsRequest(updateMuteAllCheckAppsRequest UpdateMuteAllCheckAppsRequest) ApiUpdateMuteChecksRequest {
	r.updateMuteAllCheckAppsRequest = &updateMuteAllCheckAppsRequest
	return r
}

func (r ApiUpdateMuteChecksRequest) Execute() (*UpdateMuteCheckApps200Response, *http.Response, error) {
	return r.ApiService.UpdateMuteChecksExecute(r)
}

/*
UpdateMuteChecks Mute Check

Mute an existing check.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiUpdateMuteChecksRequest
*/
func (a *ChecksAPIService) UpdateMuteChecks(ctx context.Context, id int64) ApiUpdateMuteChecksRequest {
	return ApiUpdateMuteChecksRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return UpdateMuteCheckApps200Response
func (a *ChecksAPIService) UpdateMuteChecksExecute(r ApiUpdateMuteChecksRequest) (*UpdateMuteCheckApps200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateMuteCheckApps200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChecksAPIService.UpdateMuteChecks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/monitoring/checks/{id}/mute"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateMuteAllCheckAppsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
