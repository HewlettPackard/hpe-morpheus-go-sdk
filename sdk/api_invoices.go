/*
Morpheus API

Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.

API version: 8.0.6
Contact: dev@morpheusdata.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// InvoicesAPIService InvoicesAPI service
type InvoicesAPIService service

type ApiGetInvoiceLineItemsRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	id int64
}

func (r ApiGetInvoiceLineItemsRequest) Execute() (*GetInvoiceLineItems200Response, *http.Response, error) {
	return r.ApiService.GetInvoiceLineItemsExecute(r)
}

/*
GetInvoiceLineItems Get a Specific Invoice Line Item

Get details about a specific invoice line item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Morpheus ID of the Object being referenced
 @return ApiGetInvoiceLineItemsRequest
*/
func (a *InvoicesAPIService) GetInvoiceLineItems(ctx context.Context, id int64) ApiGetInvoiceLineItemsRequest {
	return ApiGetInvoiceLineItemsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetInvoiceLineItems200Response
func (a *InvoicesAPIService) GetInvoiceLineItemsExecute(r ApiGetInvoiceLineItemsRequest) (*GetInvoiceLineItems200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetInvoiceLineItems200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.GetInvoiceLineItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/invoice-line-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoicesRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	id int64
}

func (r ApiGetInvoicesRequest) Execute() (*GetInvoices200Response, *http.Response, error) {
	return r.ApiService.GetInvoicesExecute(r)
}

/*
GetInvoices Get a Specific Invoice

Get details about a specific invoice.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Morpheus ID of the Object being referenced
 @return ApiGetInvoicesRequest
*/
func (a *InvoicesAPIService) GetInvoices(ctx context.Context, id int64) ApiGetInvoicesRequest {
	return ApiGetInvoicesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetInvoices200Response
func (a *InvoicesAPIService) GetInvoicesExecute(r ApiGetInvoicesRequest) (*GetInvoices200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetInvoices200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.GetInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/invoices/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListInvoiceLineItemsRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	max *int64
	offset *int64
	sort *string
	direction *string
	phrase *string
	name *string
	startDate *string
	endDate *string
	period *string
	refType *string
	refId *int64
	zoneId *int64
	siteId *int64
	instanceId *int64
	containerId *int64
	serverId *int64
	userId *int64
	projectId *int64
	active *bool
	accountId *int64
	includeTotals *bool
}

// Maximum number of records to return
func (r ApiListInvoiceLineItemsRequest) Max(max int64) ApiListInvoiceLineItemsRequest {
	r.max = &max
	return r
}

// Offset records, the number of records to skip, for paginating requests
func (r ApiListInvoiceLineItemsRequest) Offset(offset int64) ApiListInvoiceLineItemsRequest {
	r.offset = &offset
	return r
}

// Sort order, the name of the property to sort by
func (r ApiListInvoiceLineItemsRequest) Sort(sort string) ApiListInvoiceLineItemsRequest {
	r.sort = &sort
	return r
}

// Sort direction, use &#39;desc&#39; to reverse sort
func (r ApiListInvoiceLineItemsRequest) Direction(direction string) ApiListInvoiceLineItemsRequest {
	r.direction = &direction
	return r
}

// Search phrase for partial matches on name or description
func (r ApiListInvoiceLineItemsRequest) Phrase(phrase string) ApiListInvoiceLineItemsRequest {
	r.phrase = &phrase
	return r
}

// Filter by name
func (r ApiListInvoiceLineItemsRequest) Name(name string) ApiListInvoiceLineItemsRequest {
	r.name = &name
	return r
}

// Filter by startDate greater than or equal to a specified date
func (r ApiListInvoiceLineItemsRequest) StartDate(startDate string) ApiListInvoiceLineItemsRequest {
	r.startDate = &startDate
	return r
}

// Filter by endDate less than or equal to a specified date
func (r ApiListInvoiceLineItemsRequest) EndDate(endDate string) ApiListInvoiceLineItemsRequest {
	r.endDate = &endDate
	return r
}

// Only return records for period that matches with the specified value. This is an alternative to using startDate/endDate. Format is YYYY or YYYYMM. 
func (r ApiListInvoiceLineItemsRequest) Period(period string) ApiListInvoiceLineItemsRequest {
	r.period = &period
	return r
}

// If specified will return an exact match on refType. 
func (r ApiListInvoiceLineItemsRequest) RefType(refType string) ApiListInvoiceLineItemsRequest {
	r.refType = &refType
	return r
}

// If specified will return an exact match on refId
func (r ApiListInvoiceLineItemsRequest) RefId(refId int64) ApiListInvoiceLineItemsRequest {
	r.refId = &refId
	return r
}

// The Zone ID for Filtering
func (r ApiListInvoiceLineItemsRequest) ZoneId(zoneId int64) ApiListInvoiceLineItemsRequest {
	r.zoneId = &zoneId
	return r
}

// The Site ID for Filtering
func (r ApiListInvoiceLineItemsRequest) SiteId(siteId int64) ApiListInvoiceLineItemsRequest {
	r.siteId = &siteId
	return r
}

// The Instance ID for Filtering
func (r ApiListInvoiceLineItemsRequest) InstanceId(instanceId int64) ApiListInvoiceLineItemsRequest {
	r.instanceId = &instanceId
	return r
}

// The Container ID for Filtering
func (r ApiListInvoiceLineItemsRequest) ContainerId(containerId int64) ApiListInvoiceLineItemsRequest {
	r.containerId = &containerId
	return r
}

// The Server ID for Filtering
func (r ApiListInvoiceLineItemsRequest) ServerId(serverId int64) ApiListInvoiceLineItemsRequest {
	r.serverId = &serverId
	return r
}

// Filter by User ID
func (r ApiListInvoiceLineItemsRequest) UserId(userId int64) ApiListInvoiceLineItemsRequest {
	r.userId = &userId
	return r
}

// The Project ID for Filtering
func (r ApiListInvoiceLineItemsRequest) ProjectId(projectId int64) ApiListInvoiceLineItemsRequest {
	r.projectId = &projectId
	return r
}

// True or False flag for Active
func (r ApiListInvoiceLineItemsRequest) Active(active bool) ApiListInvoiceLineItemsRequest {
	r.active = &active
	return r
}

// Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users.
func (r ApiListInvoiceLineItemsRequest) AccountId(accountId int64) ApiListInvoiceLineItemsRequest {
	r.accountId = &accountId
	return r
}

// Pass true to include the summed totals (cost/price values) for all the invoices found in the query. The returned property is called &#x60;invoiceTotals&#x60;. 
func (r ApiListInvoiceLineItemsRequest) IncludeTotals(includeTotals bool) ApiListInvoiceLineItemsRequest {
	r.includeTotals = &includeTotals
	return r
}

func (r ApiListInvoiceLineItemsRequest) Execute() (*ListInvoiceLineItems200Response, *http.Response, error) {
	return r.ApiService.ListInvoiceLineItemsExecute(r)
}

/*
ListInvoiceLineItems List All Invoice Line Items

This endpoint retrieves a list of all invoice line items for the specified parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListInvoiceLineItemsRequest
*/
func (a *InvoicesAPIService) ListInvoiceLineItems(ctx context.Context) ApiListInvoiceLineItemsRequest {
	return ApiListInvoiceLineItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListInvoiceLineItems200Response
func (a *InvoicesAPIService) ListInvoiceLineItemsExecute(r ApiListInvoiceLineItemsRequest) (*ListInvoiceLineItems200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListInvoiceLineItems200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ListInvoiceLineItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/invoice-line-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	} else {
		var defaultValue int64 = 25
		r.max = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "name"
		r.sort = &defaultValue
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "form", "")
	} else {
		var defaultValue string = "asc"
		r.direction = &defaultValue
	}
	if r.phrase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phrase", r.phrase, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	}
	if r.refType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refType", r.refType, "form", "")
	}
	if r.refId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refId", r.refId, "form", "")
	}
	if r.zoneId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zoneId", r.zoneId, "form", "")
	}
	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceId", r.instanceId, "form", "")
	}
	if r.containerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "containerId", r.containerId, "form", "")
	}
	if r.serverId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serverId", r.serverId, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.projectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", r.projectId, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.includeTotals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTotals", r.includeTotals, "form", "")
	} else {
		var defaultValue bool = false
		r.includeTotals = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListInvoicesRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	max *int64
	offset *int64
	sort *string
	direction *string
	phrase *string
	name *string
	startDate *string
	endDate *string
	period *string
	refType *string
	refId *int64
	refStatus *string
	zoneId *int64
	siteId *int64
	instanceId *int64
	containerId *int64
	serverId *int64
	userId *int64
	projectId *int64
	active *bool
	accountId *int64
	includeLineItems *bool
	includeTotals *bool
	tagsName *string
}

// Maximum number of records to return
func (r ApiListInvoicesRequest) Max(max int64) ApiListInvoicesRequest {
	r.max = &max
	return r
}

// Offset records, the number of records to skip, for paginating requests
func (r ApiListInvoicesRequest) Offset(offset int64) ApiListInvoicesRequest {
	r.offset = &offset
	return r
}

// Sort order, the name of the property to sort by
func (r ApiListInvoicesRequest) Sort(sort string) ApiListInvoicesRequest {
	r.sort = &sort
	return r
}

// Sort direction, use &#39;desc&#39; to reverse sort
func (r ApiListInvoicesRequest) Direction(direction string) ApiListInvoicesRequest {
	r.direction = &direction
	return r
}

// Search phrase for partial matches on name or description
func (r ApiListInvoicesRequest) Phrase(phrase string) ApiListInvoicesRequest {
	r.phrase = &phrase
	return r
}

// Filter by name
func (r ApiListInvoicesRequest) Name(name string) ApiListInvoicesRequest {
	r.name = &name
	return r
}

// Filter by startDate greater than or equal to a specified date
func (r ApiListInvoicesRequest) StartDate(startDate string) ApiListInvoicesRequest {
	r.startDate = &startDate
	return r
}

// Filter by endDate less than or equal to a specified date
func (r ApiListInvoicesRequest) EndDate(endDate string) ApiListInvoicesRequest {
	r.endDate = &endDate
	return r
}

// Only return records for period that matches with the specified value. This is an alternative to using startDate/endDate. Format is YYYY or YYYYMM. 
func (r ApiListInvoicesRequest) Period(period string) ApiListInvoicesRequest {
	r.period = &period
	return r
}

// If specified will return an exact match on refType. 
func (r ApiListInvoicesRequest) RefType(refType string) ApiListInvoicesRequest {
	r.refType = &refType
	return r
}

// If specified will return an exact match on refId
func (r ApiListInvoicesRequest) RefId(refId int64) ApiListInvoicesRequest {
	r.refId = &refId
	return r
}

// If specified, will filter on the associated StorageVolume status. This is only applicable whn &#x60;refType&#x3D;StorageVolume&#x60;. 
func (r ApiListInvoicesRequest) RefStatus(refStatus string) ApiListInvoicesRequest {
	r.refStatus = &refStatus
	return r
}

// The Zone ID for Filtering
func (r ApiListInvoicesRequest) ZoneId(zoneId int64) ApiListInvoicesRequest {
	r.zoneId = &zoneId
	return r
}

// The Site ID for Filtering
func (r ApiListInvoicesRequest) SiteId(siteId int64) ApiListInvoicesRequest {
	r.siteId = &siteId
	return r
}

// The Instance ID for Filtering
func (r ApiListInvoicesRequest) InstanceId(instanceId int64) ApiListInvoicesRequest {
	r.instanceId = &instanceId
	return r
}

// The Container ID for Filtering
func (r ApiListInvoicesRequest) ContainerId(containerId int64) ApiListInvoicesRequest {
	r.containerId = &containerId
	return r
}

// The Server ID for Filtering
func (r ApiListInvoicesRequest) ServerId(serverId int64) ApiListInvoicesRequest {
	r.serverId = &serverId
	return r
}

// Filter by User ID
func (r ApiListInvoicesRequest) UserId(userId int64) ApiListInvoicesRequest {
	r.userId = &userId
	return r
}

// The Project ID for Filtering
func (r ApiListInvoicesRequest) ProjectId(projectId int64) ApiListInvoicesRequest {
	r.projectId = &projectId
	return r
}

// True or False flag for Active
func (r ApiListInvoicesRequest) Active(active bool) ApiListInvoicesRequest {
	r.active = &active
	return r
}

// Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users.
func (r ApiListInvoicesRequest) AccountId(accountId int64) ApiListInvoicesRequest {
	r.accountId = &accountId
	return r
}

// Pass true to include the list of &#x60;lineItems&#x60; for each invoice. Only &#x60;lineItemCount&#x60; is returned by default. 
func (r ApiListInvoicesRequest) IncludeLineItems(includeLineItems bool) ApiListInvoicesRequest {
	r.includeLineItems = &includeLineItems
	return r
}

// Pass true to include the summed totals (cost/price values) for all the invoices found in the query. The returned property is called &#x60;invoiceTotals&#x60;. 
func (r ApiListInvoicesRequest) IncludeTotals(includeTotals bool) ApiListInvoicesRequest {
	r.includeTotals = &includeTotals
	return r
}

// Filter by tags (metadata). This allows filtering by a tag name and value(s) 
func (r ApiListInvoicesRequest) TagsName(tagsName string) ApiListInvoicesRequest {
	r.tagsName = &tagsName
	return r
}

func (r ApiListInvoicesRequest) Execute() (*ListInvoices200Response, *http.Response, error) {
	return r.ApiService.ListInvoicesExecute(r)
}

/*
ListInvoices List All Invoices

This endpoint retrieves a list of invoices for the specified parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListInvoicesRequest
*/
func (a *InvoicesAPIService) ListInvoices(ctx context.Context) ApiListInvoicesRequest {
	return ApiListInvoicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListInvoices200Response
func (a *InvoicesAPIService) ListInvoicesExecute(r ApiListInvoicesRequest) (*ListInvoices200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListInvoices200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.ListInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/invoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	} else {
		var defaultValue int64 = 25
		r.max = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "refName"
		r.sort = &defaultValue
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "form", "")
	} else {
		var defaultValue string = "asc"
		r.direction = &defaultValue
	}
	if r.phrase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phrase", r.phrase, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	}
	if r.refType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refType", r.refType, "form", "")
	}
	if r.refId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refId", r.refId, "form", "")
	}
	if r.refStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refStatus", r.refStatus, "form", "")
	}
	if r.zoneId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zoneId", r.zoneId, "form", "")
	}
	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceId", r.instanceId, "form", "")
	}
	if r.containerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "containerId", r.containerId, "form", "")
	}
	if r.serverId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serverId", r.serverId, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.projectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", r.projectId, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = false
		r.includeLineItems = &defaultValue
	}
	if r.includeTotals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTotals", r.includeTotals, "form", "")
	} else {
		var defaultValue bool = false
		r.includeTotals = &defaultValue
	}
	if r.tagsName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags.name", r.tagsName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateInvoicesRequest struct {
	ctx context.Context
	ApiService *InvoicesAPIService
	id int64
	updateInvoicesRequest *UpdateInvoicesRequest
}

func (r ApiUpdateInvoicesRequest) UpdateInvoicesRequest(updateInvoicesRequest UpdateInvoicesRequest) ApiUpdateInvoicesRequest {
	r.updateInvoicesRequest = &updateInvoicesRequest
	return r
}

func (r ApiUpdateInvoicesRequest) Execute() (*UpdateInvoices200Response, *http.Response, error) {
	return r.ApiService.UpdateInvoicesExecute(r)
}

/*
UpdateInvoices Update Invoice Tags

Update, Add, or Remove invoice tag(s).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Morpheus ID of the Object being referenced
 @return ApiUpdateInvoicesRequest
*/
func (a *InvoicesAPIService) UpdateInvoices(ctx context.Context, id int64) ApiUpdateInvoicesRequest {
	return ApiUpdateInvoicesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return UpdateInvoices200Response
func (a *InvoicesAPIService) UpdateInvoicesExecute(r ApiUpdateInvoicesRequest) (*UpdateInvoices200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateInvoices200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoicesAPIService.UpdateInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/invoices/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateInvoicesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
