/*
Morpheus API

Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.

API version: 8.0.7
Contact: dev@morpheusdata.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"errors"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// DeploysAPIService DeploysAPI service
type DeploysAPIService service

type ApiAddInstanceDeployRequest struct {
	ctx                      context.Context
	ApiService               *DeploysAPIService
	id                       int64
	addInstanceDeployRequest *AddInstanceDeployRequest
}

func (r ApiAddInstanceDeployRequest) AddInstanceDeployRequest(addInstanceDeployRequest AddInstanceDeployRequest) ApiAddInstanceDeployRequest {
	r.addInstanceDeployRequest = &addInstanceDeployRequest
	return r
}

func (r ApiAddInstanceDeployRequest) Execute() (*UpdateDeploy200Response, *http.Response, error) {
	return r.ApiService.AddInstanceDeployExecute(r)
}

/*
AddInstanceDeploy Deploy to an Instance

This endpoint will deploy the specified deployment version to specified instance. The version to deploy can be identified with deploymentId and version or with versionId alone.

By default, the deployment is executed right away. To prevent this so that it can be run manually later on.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiAddInstanceDeployRequest
*/
func (a *DeploysAPIService) AddInstanceDeploy(ctx context.Context, id int64) ApiAddInstanceDeployRequest {
	return ApiAddInstanceDeployRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return UpdateDeploy200Response
func (a *DeploysAPIService) AddInstanceDeployExecute(r ApiAddInstanceDeployRequest) (*UpdateDeploy200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateDeploy200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.AddInstanceDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/instances/{id}/deploys"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addInstanceDeployRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletedeployRequest struct {
	ctx        context.Context
	ApiService *DeploysAPIService
	id         int64
}

func (r ApiDeletedeployRequest) Execute() (*DeleteAlerts200Response, *http.Response, error) {
	return r.ApiService.DeletedeployExecute(r)
}

/*
Deletedeploy Delete a Deploy

This endpoint will delete an archived instance deploy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiDeletedeployRequest
*/
func (a *DeploysAPIService) Deletedeploy(ctx context.Context, id int64) ApiDeletedeployRequest {
	return ApiDeletedeployRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DeleteAlerts200Response
func (a *DeploysAPIService) DeletedeployExecute(r ApiDeletedeployRequest) (*DeleteAlerts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteAlerts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.Deletedeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/deploys/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInstanceDeploysRequest struct {
	ctx          context.Context
	ApiService   *DeploysAPIService
	id           int64
	max          *int64
	offset       *int64
	phrase       *string
	name         *string
	deploymentId *int64
	instanceName *string
	instanceId   *int64
	version      *int64
	versionId    *int64
	createdById  *int64
	deployType   *string
	dateCreated  *string
	lastUpdated  *time.Time
	deployDate   *string
	status       *string
}

// Maximum number of records to return
func (r ApiGetInstanceDeploysRequest) Max(max int64) ApiGetInstanceDeploysRequest {
	r.max = &max
	return r
}

// Offset records, the number of records to skip, for paginating requests
func (r ApiGetInstanceDeploysRequest) Offset(offset int64) ApiGetInstanceDeploysRequest {
	r.offset = &offset
	return r
}

// Search phrase for partial matches on name or description
func (r ApiGetInstanceDeploysRequest) Phrase(phrase string) ApiGetInstanceDeploysRequest {
	r.phrase = &phrase
	return r
}

// Filter by name
func (r ApiGetInstanceDeploysRequest) Name(name string) ApiGetInstanceDeploysRequest {
	r.name = &name
	return r
}

// Filter by deployment id
func (r ApiGetInstanceDeploysRequest) DeploymentId(deploymentId int64) ApiGetInstanceDeploysRequest {
	r.deploymentId = &deploymentId
	return r
}

// Filter by instance name
func (r ApiGetInstanceDeploysRequest) InstanceName(instanceName string) ApiGetInstanceDeploysRequest {
	r.instanceName = &instanceName
	return r
}

// The Instance ID for Filtering
func (r ApiGetInstanceDeploysRequest) InstanceId(instanceId int64) ApiGetInstanceDeploysRequest {
	r.instanceId = &instanceId
	return r
}

// Filter by version number (userVersion)
func (r ApiGetInstanceDeploysRequest) Version(version int64) ApiGetInstanceDeploysRequest {
	r.version = &version
	return r
}

// Filter by deployment version id
func (r ApiGetInstanceDeploysRequest) VersionId(versionId int64) ApiGetInstanceDeploysRequest {
	r.versionId = &versionId
	return r
}

// Filter by owner (user) id
func (r ApiGetInstanceDeploysRequest) CreatedById(createdById int64) ApiGetInstanceDeploysRequest {
	r.createdById = &createdById
	return r
}

// Filter by type (deployType), file, git, fetch
func (r ApiGetInstanceDeploysRequest) DeployType(deployType string) ApiGetInstanceDeploysRequest {
	r.deployType = &deployType
	return r
}

// Filter by dateCreated, the created timestamp is more recent or equal to the date specified
func (r ApiGetInstanceDeploysRequest) DateCreated(dateCreated string) ApiGetInstanceDeploysRequest {
	r.dateCreated = &dateCreated
	return r
}

// Date filter, restricts query to only load resources updated more recently than the date specified (ISO 8601)
func (r ApiGetInstanceDeploysRequest) LastUpdated(lastUpdated time.Time) ApiGetInstanceDeploysRequest {
	r.lastUpdated = &lastUpdated
	return r
}

// Filter by deployDate, deployment completion timestamp is more recent or equal to the date specified
func (r ApiGetInstanceDeploysRequest) DeployDate(deployDate string) ApiGetInstanceDeploysRequest {
	r.deployDate = &deployDate
	return r
}

// Filter by status
func (r ApiGetInstanceDeploysRequest) Status(status string) ApiGetInstanceDeploysRequest {
	r.status = &status
	return r
}

func (r ApiGetInstanceDeploysRequest) Execute() (*ListDeploys200Response, *http.Response, error) {
	return r.ApiService.GetInstanceDeploysExecute(r)
}

/*
GetInstanceDeploys Get all Deploys for an Instance

This endpoint retrieves all deploys for a specific instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiGetInstanceDeploysRequest
*/
func (a *DeploysAPIService) GetInstanceDeploys(ctx context.Context, id int64) ApiGetInstanceDeploysRequest {
	return ApiGetInstanceDeploysRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ListDeploys200Response
func (a *DeploysAPIService) GetInstanceDeploysExecute(r ApiGetInstanceDeploysRequest) (*ListDeploys200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListDeploys200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.GetInstanceDeploys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/instances/{id}/deploys"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	} else {
		var defaultValue int64 = 25
		r.max = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.phrase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phrase", r.phrase, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.deploymentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deploymentId", r.deploymentId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceId", r.instanceId, "form", "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "form", "")
	}
	if r.versionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionId", r.versionId, "form", "")
	}
	if r.createdById != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdById", r.createdById, "form", "")
	}
	if r.deployType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployType", r.deployType, "form", "")
	}
	if r.dateCreated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateCreated", r.dateCreated, "form", "")
	}
	if r.lastUpdated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastUpdated", r.lastUpdated, "form", "")
	}
	if r.deployDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployDate", r.deployDate, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDeploysRequest struct {
	ctx          context.Context
	ApiService   *DeploysAPIService
	max          *int64
	offset       *int64
	phrase       *string
	name         *string
	deploymentId *int64
	instanceName *string
	instanceId   *int64
	version      *int64
	versionId    *int64
	createdById  *int64
	deployType   *string
	dateCreated  *string
	lastUpdated  *time.Time
	deployDate   *string
	status       *string
}

// Maximum number of records to return
func (r ApiListDeploysRequest) Max(max int64) ApiListDeploysRequest {
	r.max = &max
	return r
}

// Offset records, the number of records to skip, for paginating requests
func (r ApiListDeploysRequest) Offset(offset int64) ApiListDeploysRequest {
	r.offset = &offset
	return r
}

// Search phrase for partial matches on name or description
func (r ApiListDeploysRequest) Phrase(phrase string) ApiListDeploysRequest {
	r.phrase = &phrase
	return r
}

// Filter by name
func (r ApiListDeploysRequest) Name(name string) ApiListDeploysRequest {
	r.name = &name
	return r
}

// Filter by deployment id
func (r ApiListDeploysRequest) DeploymentId(deploymentId int64) ApiListDeploysRequest {
	r.deploymentId = &deploymentId
	return r
}

// Filter by instance name
func (r ApiListDeploysRequest) InstanceName(instanceName string) ApiListDeploysRequest {
	r.instanceName = &instanceName
	return r
}

// The Instance ID for Filtering
func (r ApiListDeploysRequest) InstanceId(instanceId int64) ApiListDeploysRequest {
	r.instanceId = &instanceId
	return r
}

// Filter by version number (userVersion)
func (r ApiListDeploysRequest) Version(version int64) ApiListDeploysRequest {
	r.version = &version
	return r
}

// Filter by deployment version id
func (r ApiListDeploysRequest) VersionId(versionId int64) ApiListDeploysRequest {
	r.versionId = &versionId
	return r
}

// Filter by owner (user) id
func (r ApiListDeploysRequest) CreatedById(createdById int64) ApiListDeploysRequest {
	r.createdById = &createdById
	return r
}

// Filter by type (deployType), file, git, fetch
func (r ApiListDeploysRequest) DeployType(deployType string) ApiListDeploysRequest {
	r.deployType = &deployType
	return r
}

// Filter by dateCreated, the created timestamp is more recent or equal to the date specified
func (r ApiListDeploysRequest) DateCreated(dateCreated string) ApiListDeploysRequest {
	r.dateCreated = &dateCreated
	return r
}

// Date filter, restricts query to only load resources updated more recently than the date specified (ISO 8601)
func (r ApiListDeploysRequest) LastUpdated(lastUpdated time.Time) ApiListDeploysRequest {
	r.lastUpdated = &lastUpdated
	return r
}

// Filter by deployDate, deployment completion timestamp is more recent or equal to the date specified
func (r ApiListDeploysRequest) DeployDate(deployDate string) ApiListDeploysRequest {
	r.deployDate = &deployDate
	return r
}

// Filter by status
func (r ApiListDeploysRequest) Status(status string) ApiListDeploysRequest {
	r.status = &status
	return r
}

func (r ApiListDeploysRequest) Execute() (*ListDeploys200Response, *http.Response, error) {
	return r.ApiService.ListDeploysExecute(r)
}

/*
ListDeploys Get all Deploys

This endpoint retrieves all deploys.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListDeploysRequest
*/
func (a *DeploysAPIService) ListDeploys(ctx context.Context) ApiListDeploysRequest {
	return ApiListDeploysRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListDeploys200Response
func (a *DeploysAPIService) ListDeploysExecute(r ApiListDeploysRequest) (*ListDeploys200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListDeploys200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.ListDeploys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/deploys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	} else {
		var defaultValue int64 = 25
		r.max = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.phrase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phrase", r.phrase, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.deploymentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deploymentId", r.deploymentId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceId", r.instanceId, "form", "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "form", "")
	}
	if r.versionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionId", r.versionId, "form", "")
	}
	if r.createdById != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdById", r.createdById, "form", "")
	}
	if r.deployType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployType", r.deployType, "form", "")
	}
	if r.dateCreated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateCreated", r.dateCreated, "form", "")
	}
	if r.lastUpdated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastUpdated", r.lastUpdated, "form", "")
	}
	if r.deployDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deployDate", r.deployDate, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRunDeployRequest struct {
	ctx                 context.Context
	ApiService          *DeploysAPIService
	id                  int64
	updateDeployRequest *UpdateDeployRequest
}

func (r ApiRunDeployRequest) UpdateDeployRequest(updateDeployRequest UpdateDeployRequest) ApiRunDeployRequest {
	r.updateDeployRequest = &updateDeployRequest
	return r
}

func (r ApiRunDeployRequest) Execute() (*UpdateDeploy200Response, *http.Response, error) {
	return r.ApiService.RunDeployExecute(r)
}

/*
RunDeploy Run a Deploy

This endpoint will run an existing instance deploy. This is for running a new staged deploy or to rollback to previous version by re-running a deploy that is archived.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiRunDeployRequest
*/
func (a *DeploysAPIService) RunDeploy(ctx context.Context, id int64) ApiRunDeployRequest {
	return ApiRunDeployRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return UpdateDeploy200Response
func (a *DeploysAPIService) RunDeployExecute(r ApiRunDeployRequest) (*UpdateDeploy200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateDeploy200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.RunDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/deploys/{id}/deploy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDeployRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDeployRequest struct {
	ctx                 context.Context
	ApiService          *DeploysAPIService
	id                  int64
	updateDeployRequest *UpdateDeployRequest
}

func (r ApiUpdateDeployRequest) UpdateDeployRequest(updateDeployRequest UpdateDeployRequest) ApiUpdateDeployRequest {
	r.updateDeployRequest = &updateDeployRequest
	return r
}

func (r ApiUpdateDeployRequest) Execute() (*UpdateDeploy200Response, *http.Response, error) {
	return r.ApiService.UpdateDeployExecute(r)
}

/*
UpdateDeploy Update a Deploy

This endpoint will update an existing deploy. This is typically only needed to change settings on a deploy that is staged, before it is run.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Morpheus ID of the Object being referenced
	@return ApiUpdateDeployRequest
*/
func (a *DeploysAPIService) UpdateDeploy(ctx context.Context, id int64) ApiUpdateDeployRequest {
	return ApiUpdateDeployRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return UpdateDeploy200Response
func (a *DeploysAPIService) UpdateDeployExecute(r ApiUpdateDeployRequest) (*UpdateDeploy200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdateDeploy200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.UpdateDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{err: err}
	}

	localVarPath := localBasePath + "/api/deploys/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDeployRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity5XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.err = err
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.err = errors.New(formatErrorMessage(localVarHTTPResponse.Status, &v))
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body: localVarBody,
			err:  err,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
