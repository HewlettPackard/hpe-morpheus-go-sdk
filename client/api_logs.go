/*
Morpheus API

Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.

API version: 8.0.6
Contact: dev@morpheusdata.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"time"
)


// LogsAPIService LogsAPI service
type LogsAPIService service

type ApiListLogsRequest struct {
	ctx context.Context
	ApiService *LogsAPIService
	max *int64
	offset *int64
	sort *string
	order *string
	query *string
	message *string
	sourceType *string
	typeCode *string
	objectId *int64
	token *string
	level *string
	startMs *int64
	endMs *int64
	startDateTime *time.Time
	endDateTime *time.Time
	containers *int64
	servers *int64
	clusterId *int64
}

// Maximum number of records to return
func (r ApiListLogsRequest) Max(max int64) ApiListLogsRequest {
	r.max = &max
	return r
}

// Offset records, the number of records to skip, for paginating requests
func (r ApiListLogsRequest) Offset(offset int64) ApiListLogsRequest {
	r.offset = &offset
	return r
}

// Sort order, the name of the property to sort by
func (r ApiListLogsRequest) Sort(sort string) ApiListLogsRequest {
	r.sort = &sort
	return r
}

// Sort direction, use &#39;desc&#39; to reverse sort
func (r ApiListLogsRequest) Order(order string) ApiListLogsRequest {
	r.order = &order
	return r
}

// Alias for phrase
func (r ApiListLogsRequest) Query(query string) ApiListLogsRequest {
	r.query = &query
	return r
}

// Filter by message
func (r ApiListLogsRequest) Message(message string) ApiListLogsRequest {
	r.message = &message
	return r
}

// Filter by source type
func (r ApiListLogsRequest) SourceType(sourceType string) ApiListLogsRequest {
	r.sourceType = &sourceType
	return r
}

// Filter by code type
func (r ApiListLogsRequest) TypeCode(typeCode string) ApiListLogsRequest {
	r.typeCode = &typeCode
	return r
}

// Filter by objectId
func (r ApiListLogsRequest) ObjectId(objectId int64) ApiListLogsRequest {
	r.objectId = &objectId
	return r
}

// Filter by token
func (r ApiListLogsRequest) Token(token string) ApiListLogsRequest {
	r.token = &token
	return r
}

// Filter by log level. Multiple values can be passed pipe delimited.
func (r ApiListLogsRequest) Level(level string) ApiListLogsRequest {
	r.level = &level
	return r
}

// Date filter in milliseconds (unix epoch), restricts query to only load logs updated more recently than the time specified.
func (r ApiListLogsRequest) StartMs(startMs int64) ApiListLogsRequest {
	r.startMs = &startMs
	return r
}

// Date filter in milliseconds (unix epoch), restricts query to only load logs updated before the time specified.
func (r ApiListLogsRequest) EndMs(endMs int64) ApiListLogsRequest {
	r.endMs = &endMs
	return r
}

// Start Date timestamp (ISO 8601)
func (r ApiListLogsRequest) StartDateTime(startDateTime time.Time) ApiListLogsRequest {
	r.startDateTime = &startDateTime
	return r
}

// End Date timestamp (ISO 8601)
func (r ApiListLogsRequest) EndDateTime(endDateTime time.Time) ApiListLogsRequest {
	r.endDateTime = &endDateTime
	return r
}

// The Container ID(s) for filtering. Accepts multiple values.
func (r ApiListLogsRequest) Containers(containers int64) ApiListLogsRequest {
	r.containers = &containers
	return r
}

// The Server ID(s) for filtering. Accepts multiple values.
func (r ApiListLogsRequest) Servers(servers int64) ApiListLogsRequest {
	r.servers = &servers
	return r
}

// The Cluster ID(s) for filtering. Accepts multiple values.
func (r ApiListLogsRequest) ClusterId(clusterId int64) ApiListLogsRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiListLogsRequest) Execute() (*ListLogs200Response, *http.Response, error) {
	return r.ApiService.ListLogsExecute(r)
}

/*
ListLogs Retrieves Logs

Retrieves logs based on filters provided.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListLogsRequest
*/
func (a *LogsAPIService) ListLogs(ctx context.Context) ApiListLogsRequest {
	return ApiListLogsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListLogs200Response
func (a *LogsAPIService) ListLogsExecute(r ApiListLogsRequest) (*ListLogs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListLogs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogsAPIService.ListLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	} else {
		var defaultValue int64 = 25
		r.max = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "name"
		r.sort = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
		var defaultValue string = "asc"
		r.order = &defaultValue
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "form", "")
	}
	if r.sourceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceType", r.sourceType, "form", "")
	}
	if r.typeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeCode", r.typeCode, "form", "")
	}
	if r.objectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectId", r.objectId, "form", "")
	}
	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.startMs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startMs", r.startMs, "form", "")
	}
	if r.endMs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endMs", r.endMs, "form", "")
	}
	if r.startDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDateTime", r.startDateTime, "form", "")
	}
	if r.endDateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDateTime", r.endDateTime, "form", "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "containers", r.containers, "form", "")
	}
	if r.servers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "servers", r.servers, "form", "")
	}
	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusterId", r.clusterId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v ListActivity4XXResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
